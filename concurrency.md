---
permalink: /concurrency.html
---

# 并发
## 线程
### 并行 vs. 并发
* 并行：多个任务同时运行在CPU上，共享内存空间，增大吞吐率，通常为多核处理器或多个处理器
* 并发：多个任务交替运行，形成同时运行的效果。多个线程同时对共享资源进行访问，减少响应时间，增加资源利用率
### 线程 vs. 进程
* 进程：
  * 资源分配的单位，也是调度的单位，会在不同进程中不停切换
  * 一个进程中运行多个线程
* 线程：
  * 在进程中共享资源，对各线程在同一进程中，共享全部资源
  * 不同线程分成不同段，每个线程具有独立的站
### 互斥 mutex
* 临界区：多个线程同时访问同一个资源并进行修改(临界区)，导致错误产生
* 原子性：以互斥的方式访问，同一时间只有一个进程进入临界区
* 实现锁
  * 互斥
  * 公平性
  * 开销较小
* Peterson算法
  * 两个变量控制，flag和turn。每个进程先举旗flag并将位置turn让给对方。只有当flag和turn条件都满足时才可进入。
  * 问题：while浪费CPU周期，没有做实际工作
  * 软件实现可能会发生同时进入自旋的情况
  * 使用硬件：原子指令

## 锁
### 控制中断方式
* 可能被滥用
* 不支持多处理器
* 关闭中断导致中断丢失
### 自旋锁
* 使用while实现，条件不满足则一直自旋等待
* 使用atomic exchange原子指令获得锁
* 使用compare-and-set实现
* 使用fetch-and-add实现
* 公平性不能保证，得到锁的机会随机
  * 使用队列存储线程请求，依次使用
* 性能：会有自旋开销
  * 使用yield()，让出CPU权限
### 两阶段锁
* 第一阶段：自旋一段时间，希望得到锁
* 第二阶段：若第一阶段没有锁，则调用睡眠，直到锁可用


## 死锁
### 条件
* 互斥：资源在某个时刻只能一个进程使用
* 持有并等待：持有至少一个资源，等待另一个资源
* 非抢占：只有其他进程释放后才可使用，其他进程不可以抢占资源
* 环状等待：形成等待环形链条
  * 注：环状等待不一定造成死锁，一个资源可以由多个实例

### 处理死锁
#### 预防：让四个条件中的一个永远不发生
* 互斥：不可能共享一个资源
* 持有并等待：一次全部申请足够否则不申请资源
  * 问题：资源利用率低，中间并不需要
* 不能抢占：允许抢占，即按进程优先级抢占其他资源
* 环状等待：定义资源优先级顺序，先申请优先级低的资源
  * 可以保证至少有一个进程可以申请全部资源
#### 避免：允许其中三个发生，第四个不发生
* 不限制条件，检测换装等待是否存在(动态检测)
* 分配时检测，若成环，则不分配
* 安全状态：可找到一序列，让所有进程都运行完毕
* 只有一个实例：检测资源分配图是否有环，假定分配形成死锁，则不进行分配
* 多个实例：银行家算法
#### 银行家算法
* 几个变量
  * available：系统中目前可用的各个资源
  * max：每个进程对应资源的最大需求量
  * allocation：即已经分配的资源
  * need：还需要的资源量
  * need = max - allocation
* 算法步骤
  * 使用max和allocation计算得need
  * 使用当前available与need进行比较，若满足，则将该进程allocation释放到available中
  * 若存在一种序列可满足所有进程，则无死锁，并按该顺序分配
  * 若不存在这样的序列，则存在死锁
### 死锁检测及死锁解决
* 存在死锁状态：使用动态检测，寻找环
* 关键：选择哪个进程终止？
  * 所有进程？
* 终止顺序
  * 进程优先级
  * 进程运行时间
  * 进程占用资源多
  * 进程需要资源数
  * 进程类型

## 条件变量
### 并发的两个要求
* 互斥：共享的资源不能被多个资源同时访问
* 同步：多个线程按某种顺序执行
### 条件变量和锁同时使用
* 条件变量是一个显式队列，若不满足，则线程把自己加入一个队列
* 其他线程若改变状态，则可以唤醒一个或多个队列
* pthread_cond_wait 自我休眠
* pthread_cond_signal 唤醒其他进程
* pthread_cond_broadcast也可以广播其状态
* 在使用条件变量时必须有状态值
### 生产者消费者问题
* 生产依赖关系，即消费者必须依赖生产者生产
* 有限的缓冲区，即生产者最大数量有限
* 若一个生产者多个消费者会出现问题：在不该唤醒时唤醒
  * if与while：使用while保证条件一定成立
  * 使用互斥锁
  


## 信号量
* 相当于锁+条件变量
### 两个操作
* wait：将信号量减一，若减一后为负数，说明资源不够。负数数量即等待的数量
* post：将信号量加一，若不满则唤醒一个
### 实现互斥
* 使用二进制信号量
* 二进制0/1，与锁等价
* 可访问临界区
### 生产消费问题
* 需要两个信号量同步生产和消费
* 需要保障互斥：mutex
* 要先获得empty/full的信号量，再获得mutex，否则会形成死锁
### 读者写者锁
* 读者可以多人，写者只能一人；读写不同时，但可以同时读
* 方案：第一个读者等待写锁，最后一个读者释放写锁
* 会存在公平性问题：一直有读者来，不能写
* 解决：有写者来，就不允许新增读者
### 哲学家就餐问题
* 5位哲学家5把叉子
* 满足
  * 同步：需要左右两把叉子
  * 互斥：一把叉子只能被一人拿起
* 死锁：所有人同时左手
  * 最多只有4个人吃东西
  * 或第五个人顺序不同
* 饥饿问题
* 并发性问题
* 定义五个信号量解决问题