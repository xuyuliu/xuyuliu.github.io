<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.3"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"heading","depth":1,"payload":{"lines":[1,3]},"content":"permalink: /memory.html"},{"type":"heading","depth":1,"payload":{"lines":[4,5]},"content":"内存虚拟化","children":[{"type":"heading","depth":2,"payload":{"lines":[6,7]},"content":"内存虚拟化原因和要求","children":[{"type":"heading","depth":3,"payload":{"lines":[7,8]},"content":"好处","children":[{"type":"list_item","depth":4,"payload":{"lines":[8,9]},"content":"便于编程，不必考虑实际地址"},{"type":"list_item","depth":4,"payload":{"lines":[9,10]},"content":"时间空间效率更高"},{"type":"list_item","depth":4,"payload":{"lines":[10,11]},"content":"保证进程之间相互隔离，互不干扰"}]},{"type":"heading","depth":3,"payload":{"lines":[11,12]},"content":"系统需求","children":[{"type":"list_item","depth":4,"payload":{"lines":[12,13]},"content":"透明性：对进程而言是透明的，无竞争"},{"type":"list_item","depth":4,"payload":{"lines":[13,14]},"content":"保护：","children":[{"type":"list_item","depth":5,"payload":{"lines":[14,15]},"content":"操作系统代码不能被访问"},{"type":"list_item","depth":5,"payload":{"lines":[15,16]},"content":"进程之间不能相互访问"}]},{"type":"list_item","depth":4,"payload":{"lines":[16,17]},"content":"效率：内存资源不被浪费，不引入额外负担"},{"type":"list_item","depth":4,"payload":{"lines":[17,18]},"content":"共享：让进程之间可以共享部分内存空间"}]},{"type":"heading","depth":3,"payload":{"lines":[18,19]},"content":"进程逻辑地址需求","children":[{"type":"list_item","depth":4,"payload":{"lines":[19,20]},"content":"地址空间：对内存的抽象。把进程相关的数映射到地址空间，各进程有独立的逻辑空间","children":[{"type":"list_item","depth":5,"payload":{"lines":[20,21]},"content":"heap：顶部，小-&gt;大"},{"type":"list_item","depth":5,"payload":{"lines":[21,22]},"content":"stack：底部：大-&gt;小"},{"type":"list_item","depth":5,"payload":{"lines":[22,23]},"content":"保存：基地址、偏移量"}]},{"type":"list_item","depth":4,"payload":{"lines":[23,24]},"content":"地址转换","children":[{"type":"list_item","depth":5,"payload":{"lines":[24,25]},"content":"将虚拟地址转换为物理地址"},{"type":"list_item","depth":5,"payload":{"lines":[25,26]},"content":"转换时间：进程创建、结束、切换"}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[28,29]},"content":"空闲空间管理","children":[{"type":"heading","depth":3,"payload":{"lines":[29,30]},"content":"碎片","children":[{"type":"list_item","depth":4,"payload":{"lines":[30,31]},"content":"外部碎片：已经分配出去的内存被浪费","children":[{"type":"list_item","depth":5,"payload":{"lines":[31,32]},"content":"解决方案：紧缩，将空间空间合并为一整块"}]},{"type":"list_item","depth":4,"payload":{"lines":[32,33]},"content":"内部碎片：回收后的内存，未分配但是不能被使用"}]},{"type":"heading","depth":3,"payload":{"lines":[33,34]},"content":"空间分配","children":[{"type":"list_item","depth":4,"payload":{"lines":[34,35]},"content":"从内存角度","children":[{"type":"list_item","depth":5,"payload":{"lines":[35,36]},"content":"按需分配，根据进程要求"},{"type":"list_item","depth":5,"payload":{"lines":[36,37]},"content":"预先分配，提前切成大小固定块"}]},{"type":"list_item","depth":4,"payload":{"lines":[37,38]},"content":"具体分配方式","children":[{"type":"list_item","depth":5,"payload":{"lines":[38,39]},"content":"内存提前切割好，将整个进程放入一个块中","children":[{"type":"list_item","depth":6,"payload":{"lines":[39,40]},"content":"块大小可以相等或不相等"},{"type":"list_item","depth":6,"payload":{"lines":[40,41]},"content":"操作简单"},{"type":"list_item","depth":6,"payload":{"lines":[41,42]},"content":"不实用，会产生内部碎片"}]},{"type":"list_item","depth":5,"payload":{"lines":[42,43]},"content":"连续内存，动态切割","children":[{"type":"list_item","depth":6,"payload":{"lines":[43,44]},"content":"会产生外部碎片"}]},{"type":"list_item","depth":5,"payload":{"lines":[44,45]},"content":"进程静态/动态分配","children":[{"type":"list_item","depth":6,"payload":{"lines":[45,46]},"content":"静态：进程在运行之前就确定空间大小，运行时不改变"},{"type":"list_item","depth":6,"payload":{"lines":[46,47]},"content":"动态：运行中动态增长，如malloc"}]},{"type":"list_item","depth":5,"payload":{"lines":[47,48]},"content":"内存固定切割/可变切割"},{"type":"list_item","depth":5,"payload":{"lines":[48,49]},"content":"将进程分割成大小相等的页，放入内存不同区域(分页)","children":[{"type":"list_item","depth":6,"payload":{"lines":[49,50]},"content":"分页方式：将进程切割成大小相等的页，内存也分割成大小相同的页框"},{"type":"list_item","depth":6,"payload":{"lines":[50,51]},"content":"优势：进程和内存大小相等，空间管理和分配较简单"}]},{"type":"list_item","depth":5,"payload":{"lines":[51,52]},"content":"将进程切成大小不等的段(分段)"}]}]},{"type":"heading","depth":3,"payload":{"lines":[52,53]},"content":"空间追踪与合并","children":[{"type":"list_item","depth":4,"payload":{"lines":[53,54]},"content":"链表表示","children":[{"type":"list_item","depth":5,"payload":{"lines":[54,55]},"content":"在分割时使用链表表示，记录开始的地址和大小"},{"type":"list_item","depth":5,"payload":{"lines":[55,56]},"content":"分配时有额外空间标记分配的空间和大小：便于回收"},{"type":"list_item","depth":5,"payload":{"lines":[56,57]},"content":"分离列表","children":[{"type":"list_item","depth":6,"payload":{"lines":[57,58]},"content":"将大小范围不同的放入不同列表中，搜索复杂度更低"},{"type":"list_item","depth":6,"payload":{"lines":[58,59]},"content":"回收时直接放入对应列表中即可"},{"type":"list_item","depth":6,"payload":{"lines":[59,60]},"content":"优点：速度更快，不必全部遍历"},{"type":"list_item","depth":6,"payload":{"lines":[60,61]},"content":"极端情况：每个大小均有一个列表"}]},{"type":"list_item","depth":5,"payload":{"lines":[61,62]},"content":"厚块分配(Slab Allocator)：预先申请较大内存，再进行分割，主要用于使用频繁、大小较小的内存需求"},{"type":"list_item","depth":5,"payload":{"lines":[62,63]},"content":"伙伴系统(Buddy Allocation)：按照2^N的方式进行分割，便于合并"}]},{"type":"list_item","depth":4,"payload":{"lines":[63,64]},"content":"合并策略","children":[{"type":"list_item","depth":5,"payload":{"lines":[64,65]},"content":"立即合并：每次需要遍历，复杂度较高"},{"type":"list_item","depth":5,"payload":{"lines":[65,66]},"content":"推迟合并：空间不够时再进行分配"}]},{"type":"list_item","depth":4,"payload":{"lines":[66,67]},"content":"回收策略","children":[{"type":"list_item","depth":5,"payload":{"lines":[67,68]},"content":"插入链表开头"},{"type":"list_item","depth":5,"payload":{"lines":[68,69]},"content":"按照地址排序：便于合并"},{"type":"list_item","depth":5,"payload":{"lines":[69,70]},"content":"按照大小排序：便于分配"}]},{"type":"list_item","depth":4,"payload":{"lines":[70,71]},"content":"分配策略","children":[{"type":"list_item","depth":5,"payload":{"lines":[71,72]},"content":"最佳匹配(best fit)：选择最接近的进行匹配","children":[{"type":"list_item","depth":6,"payload":{"lines":[72,73]},"content":"时间代价较高"}]},{"type":"list_item","depth":5,"payload":{"lines":[73,74]},"content":"最差匹配(worst fit)：寻找最大项进行分配","children":[{"type":"list_item","depth":6,"payload":{"lines":[74,75]},"content":"时间代价高且会产生较多碎片"}]},{"type":"list_item","depth":5,"payload":{"lines":[75,76]},"content":"首次匹配(first fit)：第一个满足要求的块","children":[{"type":"list_item","depth":6,"payload":{"lines":[76,77]},"content":"重复使用同一个位置"},{"type":"list_item","depth":6,"payload":{"lines":[77,78]},"content":"速度较快"}]},{"type":"list_item","depth":5,"payload":{"lines":[78,79]},"content":"下次匹配(next fit)：从上一次分配的位置开始搜索，首个满足的块","children":[{"type":"list_item","depth":6,"payload":{"lines":[79,80]},"content":"避免遍历和对开头区域的重复使用"}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[84,85]},"content":"段式管理","children":[{"type":"heading","depth":3,"payload":{"lines":[85,86]},"content":"分块方式","children":[{"type":"list_item","depth":4,"payload":{"lines":[86,87]},"content":"粗粒度：按照进程本身的code、heap、stack形式划分"},{"type":"list_item","depth":4,"payload":{"lines":[87,88]},"content":"细粒度：更加灵活"}]},{"type":"heading","depth":3,"payload":{"lines":[88,89]},"content":"段地址转换","children":[{"type":"list_item","depth":4,"payload":{"lines":[89,90]},"content":"逻辑地址：段号，偏移"},{"type":"list_item","depth":4,"payload":{"lines":[90,92]},"content":"段表实现映射关系：段基地址和段界限<br>\n对逻辑地址和物理地址进行编号，物理地址=段号+虚拟地址"}]},{"type":"heading","depth":3,"payload":{"lines":[92,93]},"content":"实现共享","children":[{"type":"list_item","depth":4,"payload":{"lines":[93,94]},"content":"映射到同一物理区域"},{"type":"list_item","depth":4,"payload":{"lines":[94,95]},"content":"限制读写权限"}]}]},{"type":"heading","depth":2,"payload":{"lines":[97,98]},"content":"页式管理","children":[{"type":"heading","depth":3,"payload":{"lines":[98,99]},"content":"核心思想"},{"type":"heading","depth":3,"payload":{"lines":[100,101]},"content":"地址转换","children":[{"type":"list_item","depth":4,"payload":{"lines":[101,102]},"content":"逻辑地址=页号+页内偏移量，将页号替换成物理地址帧号"},{"type":"list_item","depth":4,"payload":{"lines":[102,103]},"content":"页表：记录虚拟页号与物理帧号的对应关系，由进程维护"},{"type":"list_item","depth":4,"payload":{"lines":[103,104]},"content":"问题：较慢，需要访问两次内存，查页表和内存"}]},{"type":"heading","depth":3,"payload":{"lines":[104,105]},"content":"页表过大","children":[{"type":"list_item","depth":4,"payload":{"lines":[105,106]},"content":"将页大小变大","children":[{"type":"list_item","depth":5,"payload":{"lines":[106,107]},"content":"缺点：会产生内部碎片问题"}]},{"type":"list_item","depth":4,"payload":{"lines":[107,108]},"content":"将段式管理与页式管理结合","children":[{"type":"list_item","depth":5,"payload":{"lines":[108,109]},"content":"将进程划分为段，每个段中有多个页"},{"type":"list_item","depth":5,"payload":{"lines":[109,110]},"content":"段优势：支持稀疏的地址空间"},{"type":"list_item","depth":5,"payload":{"lines":[110,111]},"content":"页优势：没有外部碎片"}]},{"type":"list_item","depth":4,"payload":{"lines":[111,112]},"content":"多级页表","children":[{"type":"list_item","depth":5,"payload":{"lines":[112,113]},"content":"将页表切成大小相同的页"},{"type":"list_item","depth":5,"payload":{"lines":[113,114]},"content":"设置目录表，可以有多级"},{"type":"list_item","depth":5,"payload":{"lines":[114,115]},"content":"无效页表不用表示"},{"type":"list_item","depth":5,"payload":{"lines":[115,116]},"content":"优势：节省空间，支持增长"},{"type":"list_item","depth":5,"payload":{"lines":[116,117]},"content":"缺点：牺牲时间"}]},{"type":"list_item","depth":4,"payload":{"lines":[117,118]},"content":"反向页表/倒排页表","children":[{"type":"list_item","depth":5,"payload":{"lines":[118,119]},"content":"整个系统保留一个页表，记录使用的物理页帧"},{"type":"list_item","depth":5,"payload":{"lines":[119,120]},"content":"使用hash进行记录"}]}]},{"type":"heading","depth":3,"payload":{"lines":[121,122]},"content":"TLB","children":[{"type":"list_item","depth":4,"payload":{"lines":[122,123]},"content":"页式管理不足：页表较大"},{"type":"list_item","depth":4,"payload":{"lines":[123,124]},"content":"解决方式：使用cache缓存","children":[{"type":"list_item","depth":5,"payload":{"lines":[124,125]},"content":"成本高，大小较小-&gt;只能存放部分内容"}]},{"type":"list_item","depth":4,"payload":{"lines":[125,126]},"content":"局部性要求","children":[{"type":"list_item","depth":5,"payload":{"lines":[126,127]},"content":"时间局部性：短期内访问次数较多"},{"type":"list_item","depth":5,"payload":{"lines":[127,128]},"content":"空间局部性：内存地址较为靠近"}]},{"type":"list_item","depth":4,"payload":{"lines":[128,129]},"content":"提升命中率","children":[{"type":"list_item","depth":5,"payload":{"lines":[129,130]},"content":"增大页面大小"},{"type":"list_item","depth":5,"payload":{"lines":[130,131]},"content":"TLB替换算法"}]},{"type":"list_item","depth":4,"payload":{"lines":[131,132]},"content":"不命中处理方式","children":[{"type":"list_item","depth":5,"payload":{"lines":[132,133]},"content":"CISC：由硬件实现，将物理地址放入TLB中"},{"type":"list_item","depth":5,"payload":{"lines":[133,134]},"content":"RISC：由软件处理，提权到内核态，使用陷入处理"}]},{"type":"list_item","depth":4,"payload":{"lines":[134,135]},"content":"进程切换","children":[{"type":"list_item","depth":5,"payload":{"lines":[135,136]},"content":"各进程不同页表都存储再TLB中，若无PID，会引起歧义"},{"type":"list_item","depth":5,"payload":{"lines":[136,137]},"content":"切换时，全部更新TLB中的内容"},{"type":"list_item","depth":5,"payload":{"lines":[137,138]},"content":"在TLB中增加ASID，与PID类似，更短"},{"type":"list_item","depth":5,"payload":{"lines":[138,139]},"content":"TLB也可映射到同一空间实现共享"}]}]},{"type":"heading","depth":3,"payload":{"lines":[141,142]},"content":"交换","children":[{"type":"list_item","depth":4,"payload":{"lines":[142,143]},"content":"实现快速和大容量的需求，将不用的放在外存的交换空间之中","children":[{"type":"list_item","depth":5,"payload":{"lines":[143,144]},"content":"每个进程在运行中并非所有页面都可以被用到"},{"type":"list_item","depth":5,"payload":{"lines":[144,145]},"content":"内存空间装满：将暂时不用的部分交换进去"}]},{"type":"list_item","depth":4,"payload":{"lines":[145,146]},"content":"页表中需要加入present bit，指示是否在内存中"},{"type":"list_item","depth":4,"payload":{"lines":[146,147]},"content":"缺页：在硬盘中查找，进行替换","children":[{"type":"list_item","depth":5,"payload":{"lines":[147,148]},"content":"替换时机：","children":[{"type":"list_item","depth":6,"payload":{"lines":[148,149]},"content":"被动"},{"type":"list_item","depth":6,"payload":{"lines":[149,150]},"content":"主动，预取替换"}]}]}]},{"type":"heading","depth":3,"payload":{"lines":[150,151]},"content":"替换算法","children":[{"type":"list_item","depth":4,"payload":{"lines":[151,152]},"content":"评价指标 AMAT，平均内存访问时间"},{"type":"list_item","depth":4,"payload":{"lines":[152,153]},"content":"OPT","children":[{"type":"list_item","depth":5,"payload":{"lines":[153,154]},"content":"在未来一段时间不会被用到的替换出去"},{"type":"list_item","depth":5,"payload":{"lines":[154,155]},"content":"只能事后判断，是理想化的方法"},{"type":"list_item","depth":5,"payload":{"lines":[155,156]},"content":"未命中次数最低"}]},{"type":"list_item","depth":4,"payload":{"lines":[156,157]},"content":"FIFO","children":[{"type":"list_item","depth":5,"payload":{"lines":[157,158]},"content":"先入先出，维护一个队列，实现方便"},{"type":"list_item","depth":5,"payload":{"lines":[158,159]},"content":"无法确定页的重要性，即无法确定最近是否还会使用"},{"type":"list_item","depth":5,"payload":{"lines":[159,160]},"content":"Belady异常：增加缓存大小反而命中率降低"}]},{"type":"list_item","depth":4,"payload":{"lines":[160,161]},"content":"RAND","children":[{"type":"list_item","depth":5,"payload":{"lines":[161,162]},"content":"随机访问，一些情况下也可取得较好效果"}]},{"type":"list_item","depth":4,"payload":{"lines":[162,163]},"content":"LRU","children":[{"type":"list_item","depth":5,"payload":{"lines":[163,164]},"content":"将最久未访问的替换出去"},{"type":"list_item","depth":5,"payload":{"lines":[164,165]},"content":"可提高命中率"},{"type":"list_item","depth":5,"payload":{"lines":[165,166]},"content":"相反的思路MRU，忽视局部性特点，效果不好"}]},{"type":"list_item","depth":4,"payload":{"lines":[166,167]},"content":"LFU","children":[{"type":"list_item","depth":5,"payload":{"lines":[167,168]},"content":"将访问频率最低的替换出去"},{"type":"list_item","depth":5,"payload":{"lines":[168,169]},"content":"基于局部性原则"},{"type":"list_item","depth":5,"payload":{"lines":[169,170]},"content":"但是维护开销较大"},{"type":"list_item","depth":5,"payload":{"lines":[170,171]},"content":"也有相反的思路MFU，忽视局部性特点，效果不好"}]},{"type":"list_item","depth":4,"payload":{"lines":[171,172]},"content":"CLOCK","children":[{"type":"list_item","depth":5,"payload":{"lines":[172,173]},"content":"近似LRU的方式"},{"type":"list_item","depth":5,"payload":{"lines":[173,174]},"content":"将所有也放在循环列表中"},{"type":"list_item","depth":5,"payload":{"lines":[174,175]},"content":"通过使用位的值进行判断是否最近被使用过","children":[{"type":"list_item","depth":6,"payload":{"lines":[175,176]},"content":"找到第一个为0的位置进行替换"},{"type":"list_item","depth":6,"payload":{"lines":[176,177]},"content":"在寻找过程中将1置为0"},{"type":"list_item","depth":6,"payload":{"lines":[177,178]},"content":"使用位可以使用多位存储"}]}]},{"type":"list_item","depth":4,"payload":{"lines":[178,179]},"content":"脏页","children":[{"type":"list_item","depth":5,"payload":{"lines":[179,180]},"content":"记录页面是否被修改"},{"type":"list_item","depth":5,"payload":{"lines":[180,181]},"content":"倾向踢出干净页"}]},{"type":"list_item","depth":4,"payload":{"lines":[181,182]},"content":"预取","children":[{"type":"list_item","depth":5,"payload":{"lines":[182,183]},"content":"推测接下来使用页面的可能"}]}]}]}]}],"payload":{}},{})</script>
</body>
</html>
