<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.3"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[0,1]},"content":"并发","children":[{"type":"heading","depth":1,"payload":{"lines":[1,2]},"content":"线程","children":[{"type":"heading","depth":2,"payload":{"lines":[2,3]},"content":"并行 vs. 并发","children":[{"type":"list_item","depth":3,"payload":{"lines":[3,4]},"content":"并行：多个任务同时运行在CPU上，共享内存空间，增大吞吐率，通常为多核处理器或多个处理器"},{"type":"list_item","depth":3,"payload":{"lines":[4,5]},"content":"并发：多个任务交替运行，形成同时运行的效果。多个线程同时对共享资源进行访问，减少响应时间，增加资源利用率"}]},{"type":"heading","depth":2,"payload":{"lines":[5,6]},"content":"线程 vs. 进程","children":[{"type":"list_item","depth":3,"payload":{"lines":[6,7]},"content":"进程：","children":[{"type":"list_item","depth":4,"payload":{"lines":[7,8]},"content":"资源分配的单位，也是调度的单位，会在不同进程中不停切换"},{"type":"list_item","depth":4,"payload":{"lines":[8,9]},"content":"一个进程中运行多个线程"}]},{"type":"list_item","depth":3,"payload":{"lines":[9,10]},"content":"线程：","children":[{"type":"list_item","depth":4,"payload":{"lines":[10,11]},"content":"在进程中共享资源，对各线程在同一进程中，共享全部资源"},{"type":"list_item","depth":4,"payload":{"lines":[11,12]},"content":"不同线程分成不同段，每个线程具有独立的站"}]}]},{"type":"heading","depth":2,"payload":{"lines":[12,13]},"content":"互斥 mutex","children":[{"type":"list_item","depth":3,"payload":{"lines":[13,14]},"content":"临界区：多个线程同时访问同一个资源并进行修改(临界区)，导致错误产生"},{"type":"list_item","depth":3,"payload":{"lines":[14,15]},"content":"原子性：以互斥的方式访问，同一时间只有一个进程进入临界区"},{"type":"list_item","depth":3,"payload":{"lines":[15,16]},"content":"实现锁","children":[{"type":"list_item","depth":4,"payload":{"lines":[16,17]},"content":"互斥"},{"type":"list_item","depth":4,"payload":{"lines":[17,18]},"content":"公平性"},{"type":"list_item","depth":4,"payload":{"lines":[18,19]},"content":"开销较小"}]},{"type":"list_item","depth":3,"payload":{"lines":[19,20]},"content":"Peterson算法","children":[{"type":"list_item","depth":4,"payload":{"lines":[20,21]},"content":"两个变量控制，flag和turn。每个进程先举旗flag并将位置turn让给对方。只有当flag和turn条件都满足时才可进入。"},{"type":"list_item","depth":4,"payload":{"lines":[21,22]},"content":"问题：while浪费CPU周期，没有做实际工作"},{"type":"list_item","depth":4,"payload":{"lines":[22,23]},"content":"软件实现可能会发生同时进入自旋的情况"},{"type":"list_item","depth":4,"payload":{"lines":[23,24]},"content":"使用硬件：原子指令"}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[25,26]},"content":"锁","children":[{"type":"heading","depth":2,"payload":{"lines":[26,27]},"content":"控制中断方式","children":[{"type":"list_item","depth":3,"payload":{"lines":[27,28]},"content":"可能被滥用"},{"type":"list_item","depth":3,"payload":{"lines":[28,29]},"content":"不支持多处理器"},{"type":"list_item","depth":3,"payload":{"lines":[29,30]},"content":"关闭中断导致中断丢失"}]},{"type":"heading","depth":2,"payload":{"lines":[30,31]},"content":"自旋锁","children":[{"type":"list_item","depth":3,"payload":{"lines":[31,32]},"content":"使用while实现，条件不满足则一直自旋等待"},{"type":"list_item","depth":3,"payload":{"lines":[32,33]},"content":"使用atomic exchange原子指令获得锁"},{"type":"list_item","depth":3,"payload":{"lines":[33,34]},"content":"使用compare-and-set实现"},{"type":"list_item","depth":3,"payload":{"lines":[34,35]},"content":"使用fetch-and-add实现"},{"type":"list_item","depth":3,"payload":{"lines":[35,36]},"content":"公平性不能保证，得到锁的机会随机","children":[{"type":"list_item","depth":4,"payload":{"lines":[36,37]},"content":"使用队列存储线程请求，依次使用"}]},{"type":"list_item","depth":3,"payload":{"lines":[37,38]},"content":"性能：会有自旋开销","children":[{"type":"list_item","depth":4,"payload":{"lines":[38,39]},"content":"使用yield()，让出CPU权限"}]}]},{"type":"heading","depth":2,"payload":{"lines":[39,40]},"content":"两阶段锁","children":[{"type":"list_item","depth":3,"payload":{"lines":[40,41]},"content":"第一阶段：自旋一段时间，希望得到锁"},{"type":"list_item","depth":3,"payload":{"lines":[41,42]},"content":"第二阶段：若第一阶段没有锁，则调用睡眠，直到锁可用"}]}]},{"type":"heading","depth":1,"payload":{"lines":[44,45]},"content":"死锁","children":[{"type":"heading","depth":2,"payload":{"lines":[45,46]},"content":"条件","children":[{"type":"list_item","depth":3,"payload":{"lines":[46,47]},"content":"互斥：资源在某个时刻只能一个进程使用"},{"type":"list_item","depth":3,"payload":{"lines":[47,48]},"content":"持有并等待：持有至少一个资源，等待另一个资源"},{"type":"list_item","depth":3,"payload":{"lines":[48,49]},"content":"非抢占：只有其他进程释放后才可使用，其他进程不可以抢占资源"},{"type":"list_item","depth":3,"payload":{"lines":[49,50]},"content":"环状等待：形成等待环形链条","children":[{"type":"list_item","depth":4,"payload":{"lines":[50,51]},"content":"注：环状等待不一定造成死锁，一个资源可以由多个实例"}]}]},{"type":"heading","depth":2,"payload":{"lines":[52,53]},"content":"处理死锁","children":[{"type":"heading","depth":3,"payload":{"lines":[53,54]},"content":"预防：让四个条件中的一个永远不发生","children":[{"type":"list_item","depth":4,"payload":{"lines":[54,55]},"content":"互斥：不可能共享一个资源"},{"type":"list_item","depth":4,"payload":{"lines":[55,56]},"content":"持有并等待：一次全部申请足够否则不申请资源","children":[{"type":"list_item","depth":5,"payload":{"lines":[56,57]},"content":"问题：资源利用率低，中间并不需要"}]},{"type":"list_item","depth":4,"payload":{"lines":[57,58]},"content":"不能抢占：允许抢占，即按进程优先级抢占其他资源"},{"type":"list_item","depth":4,"payload":{"lines":[58,59]},"content":"环状等待：定义资源优先级顺序，先申请优先级低的资源","children":[{"type":"list_item","depth":5,"payload":{"lines":[59,60]},"content":"可以保证至少有一个进程可以申请全部资源"}]}]},{"type":"heading","depth":3,"payload":{"lines":[60,61]},"content":"避免：允许其中三个发生，第四个不发生","children":[{"type":"list_item","depth":4,"payload":{"lines":[61,62]},"content":"不限制条件，检测换装等待是否存在(动态检测)"},{"type":"list_item","depth":4,"payload":{"lines":[62,63]},"content":"分配时检测，若成环，则不分配"},{"type":"list_item","depth":4,"payload":{"lines":[63,64]},"content":"安全状态：可找到一序列，让所有进程都运行完毕"},{"type":"list_item","depth":4,"payload":{"lines":[64,65]},"content":"只有一个实例：检测资源分配图是否有环，假定分配形成死锁，则不进行分配"},{"type":"list_item","depth":4,"payload":{"lines":[65,66]},"content":"多个实例：银行家算法"}]},{"type":"heading","depth":3,"payload":{"lines":[66,67]},"content":"银行家算法","children":[{"type":"list_item","depth":4,"payload":{"lines":[67,68]},"content":"几个变量","children":[{"type":"list_item","depth":5,"payload":{"lines":[68,69]},"content":"available：系统中目前可用的各个资源"},{"type":"list_item","depth":5,"payload":{"lines":[69,70]},"content":"max：每个进程对应资源的最大需求量"},{"type":"list_item","depth":5,"payload":{"lines":[70,71]},"content":"allocation：即已经分配的资源"},{"type":"list_item","depth":5,"payload":{"lines":[71,72]},"content":"need：还需要的资源量"},{"type":"list_item","depth":5,"payload":{"lines":[72,73]},"content":"need = max - allocation"}]},{"type":"list_item","depth":4,"payload":{"lines":[73,74]},"content":"算法步骤","children":[{"type":"list_item","depth":5,"payload":{"lines":[74,75]},"content":"使用max和allocation计算得need"},{"type":"list_item","depth":5,"payload":{"lines":[75,76]},"content":"使用当前available与need进行比较，若满足，则将该进程allocation释放到available中"},{"type":"list_item","depth":5,"payload":{"lines":[76,77]},"content":"若存在一种序列可满足所有进程，则无死锁，并按该顺序分配"},{"type":"list_item","depth":5,"payload":{"lines":[77,78]},"content":"若不存在这样的序列，则存在死锁"}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[78,79]},"content":"死锁检测及死锁解决","children":[{"type":"list_item","depth":3,"payload":{"lines":[79,80]},"content":"存在死锁状态：使用动态检测，寻找环"},{"type":"list_item","depth":3,"payload":{"lines":[80,81]},"content":"关键：选择哪个进程终止？","children":[{"type":"list_item","depth":4,"payload":{"lines":[81,82]},"content":"所有进程？"}]},{"type":"list_item","depth":3,"payload":{"lines":[82,83]},"content":"终止顺序","children":[{"type":"list_item","depth":4,"payload":{"lines":[83,84]},"content":"进程优先级"},{"type":"list_item","depth":4,"payload":{"lines":[84,85]},"content":"进程运行时间"},{"type":"list_item","depth":4,"payload":{"lines":[85,86]},"content":"进程占用资源多"},{"type":"list_item","depth":4,"payload":{"lines":[86,87]},"content":"进程需要资源数"},{"type":"list_item","depth":4,"payload":{"lines":[87,88]},"content":"进程类型"}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[89,90]},"content":"条件变量","children":[{"type":"heading","depth":2,"payload":{"lines":[90,91]},"content":"并发的两个要求","children":[{"type":"list_item","depth":3,"payload":{"lines":[91,92]},"content":"互斥：共享的资源不能被多个资源同时访问"},{"type":"list_item","depth":3,"payload":{"lines":[92,93]},"content":"同步：多个线程按某种顺序执行"}]},{"type":"heading","depth":2,"payload":{"lines":[93,94]},"content":"条件变量和锁同时使用","children":[{"type":"list_item","depth":3,"payload":{"lines":[94,95]},"content":"条件变量是一个显式队列，若不满足，则线程把自己加入一个队列"},{"type":"list_item","depth":3,"payload":{"lines":[95,96]},"content":"其他线程若改变状态，则可以唤醒一个或多个队列"},{"type":"list_item","depth":3,"payload":{"lines":[96,97]},"content":"pthread_cond_wait 自我休眠"},{"type":"list_item","depth":3,"payload":{"lines":[97,98]},"content":"pthread_cond_signal 唤醒其他进程"},{"type":"list_item","depth":3,"payload":{"lines":[98,99]},"content":"pthread_cond_broadcast也可以广播其状态"},{"type":"list_item","depth":3,"payload":{"lines":[99,100]},"content":"在使用条件变量时必须有状态值"}]},{"type":"heading","depth":2,"payload":{"lines":[100,101]},"content":"生产者消费者问题","children":[{"type":"list_item","depth":3,"payload":{"lines":[101,102]},"content":"生产依赖关系，即消费者必须依赖生产者生产"},{"type":"list_item","depth":3,"payload":{"lines":[102,103]},"content":"有限的缓冲区，即生产者最大数量有限"},{"type":"list_item","depth":3,"payload":{"lines":[103,104]},"content":"若一个生产者多个消费者会出现问题：在不该唤醒时唤醒","children":[{"type":"list_item","depth":4,"payload":{"lines":[104,105]},"content":"if与while：使用while保证条件一定成立"},{"type":"list_item","depth":4,"payload":{"lines":[105,106]},"content":"使用互斥锁"}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[109,110]},"content":"信号量","children":[{"type":"bullet_list","depth":2,"payload":{"lines":[110,111]},"content":"","children":[{"type":"list_item","depth":3,"payload":{"lines":[110,111]},"content":"相当于锁+条件变量"}]},{"type":"heading","depth":2,"payload":{"lines":[111,112]},"content":"两个操作","children":[{"type":"list_item","depth":3,"payload":{"lines":[112,113]},"content":"wait：将信号量减一，若减一后为负数，说明资源不够。负数数量即等待的数量"},{"type":"list_item","depth":3,"payload":{"lines":[113,114]},"content":"post：将信号量加一，若不满则唤醒一个"}]},{"type":"heading","depth":2,"payload":{"lines":[114,115]},"content":"实现互斥","children":[{"type":"list_item","depth":3,"payload":{"lines":[115,116]},"content":"使用二进制信号量"},{"type":"list_item","depth":3,"payload":{"lines":[116,117]},"content":"二进制0/1，与锁等价"},{"type":"list_item","depth":3,"payload":{"lines":[117,118]},"content":"可访问临界区"}]},{"type":"heading","depth":2,"payload":{"lines":[118,119]},"content":"生产消费问题","children":[{"type":"list_item","depth":3,"payload":{"lines":[119,120]},"content":"需要两个信号量同步生产和消费"},{"type":"list_item","depth":3,"payload":{"lines":[120,121]},"content":"需要保障互斥：mutex"},{"type":"list_item","depth":3,"payload":{"lines":[121,122]},"content":"要先获得empty/full的信号量，再获得mutex，否则会形成死锁"}]},{"type":"heading","depth":2,"payload":{"lines":[122,123]},"content":"读者写者锁","children":[{"type":"list_item","depth":3,"payload":{"lines":[123,124]},"content":"读者可以多人，写者只能一人；读写不同时，但可以同时读"},{"type":"list_item","depth":3,"payload":{"lines":[124,125]},"content":"方案：第一个读者等待写锁，最后一个读者释放写锁"},{"type":"list_item","depth":3,"payload":{"lines":[125,126]},"content":"会存在公平性问题：一直有读者来，不能写"},{"type":"list_item","depth":3,"payload":{"lines":[126,127]},"content":"解决：有写者来，就不允许新增读者"}]},{"type":"heading","depth":2,"payload":{"lines":[127,128]},"content":"哲学家就餐问题","children":[{"type":"list_item","depth":3,"payload":{"lines":[128,129]},"content":"5位哲学家5把叉子"},{"type":"list_item","depth":3,"payload":{"lines":[129,130]},"content":"满足","children":[{"type":"list_item","depth":4,"payload":{"lines":[130,131]},"content":"同步：需要左右两把叉子"},{"type":"list_item","depth":4,"payload":{"lines":[131,132]},"content":"互斥：一把叉子只能被一人拿起"}]},{"type":"list_item","depth":3,"payload":{"lines":[132,133]},"content":"死锁：所有人同时左手","children":[{"type":"list_item","depth":4,"payload":{"lines":[133,134]},"content":"最多只有4个人吃东西"},{"type":"list_item","depth":4,"payload":{"lines":[134,135]},"content":"或第五个人顺序不同"}]},{"type":"list_item","depth":3,"payload":{"lines":[135,136]},"content":"饥饿问题"},{"type":"list_item","depth":3,"payload":{"lines":[136,137]},"content":"并发性问题"},{"type":"list_item","depth":3,"payload":{"lines":[137,138]},"content":"定义五个信号量解决问题"}]}]}]},{})</script>
</body>
</html>
